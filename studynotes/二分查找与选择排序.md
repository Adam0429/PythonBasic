# 算法简介与选择排序
## 一、二分查找
### 思路
给定一个有序元素列表，获取要查找元素所在位置索引。</br>
1、目标元素与有序列表的中间位置元素比较大小。</br>
2、如果目标元素大于中间位置元素，取列表的后半部分。</br>
3、如果目标元素小于中间位置元素，取列表的前半部分。</br>
4、循环直至找出目标元素索引。</br>
### 代码

    def binary_search(list_item,item):
        low = 0
        heigh = len(list_item)-1
        while low<heigh:
            mid = math.ceil((low+heigh)/2)
            if list_item[mid] == item:
                return mid
            elif list_item[mid] < item:
                low = mid
            elif list_item[mid] > item:
                heigh = mid
        return None

    list_item =  [1,2,3,4,5,6,7,8,9,11,22,33,44,55]
    binary_search(list_item,8)

## 二、大O表示法
### 常见的大O运行时间
O(log(n)):对数时间，二分查找算法的时间，log(n)在这里表示的是以2为底的n的对数。</br>
O(n):线性时间，简单查找算法的时间。</br>
O(n*log(n)):快速排序算法的时间，log(n)在这里表示的是以2为底的n的对数。</br>
O(n2):选择排序算法的时间，n2为n的平方。</br>

**算法的运行时间并不是以秒为单位，算法的运行时间是从其操作数n的增速度量的**
